<?xml version="1.0" encoding="UTF-8"?>
<unload unload_date="2026-01-12 18:12:10">
<sys_script_include action="INSERT_OR_UPDATE">
<access>public</access>
<active>true</active>
<api_name>global.xUpdateSetBuilder</api_name>
<caller_access/>
<client_callable>false</client_callable>
<description>@Author: github.com/derekpage3
@Date: 07/06/2020

Utility class for programmatically building update sets with specified objects.  The original use case for this was building a new update set to migrate a large application to a new ServiceNow environment, because the application was large and there were simply too many existing Update Sets to find and batch together to generate one with the entirety of the application's objects.  There may be other uses for this and so it is provided for anyone who may find it useful.

It utilizes the out of box GlideUpdateManager2 and GlideUpdateSet classes to perform the building of the update set and capture of specified objects; however it provides the user with a higher level API for this purpose, abstracting away the complications of capturing certain multi-faceted objects (especially Tables) where the user would otherwise have to explicitly code out the capture of multiple hierarchical layers of related objects, or capture multiple related objects whose relationships aren't immediately obvious.  The class provides the framework for capturing needed objects, but it's up to the user to ensure they capture all the necessary components (apart from objects that have specific methods to capture all related objects, such as Tables) to reproduce entirely the application or functionality desired.  Scripts written against this class don't immediately capture updates to a new update set, but instead queue them up and only attempts to write them to an update set when the writeUpdateSet() function is called.  This allows for iterative development and testing, and only writing an update set once you're confident you've captured all the necessary items.

A typical use-case will look something like this:

//1. Create new builder object.
var util = new xUpdateSetBuilder();

//2. Make one or more API calls to capture necessary objects.
util.captureTableWithRelatedRecords("incident");
util.captureScriptIncludeByName("MyScriptInclude");
util.captureApplicationMenuAndModules("12345fbc0fa10300e608b36be10ABCDEF");
.
.
.
//3. Finally, call writeUpdateSet() to write all captured objects to an update set.
util.writeUpdateSet("My New Update Set");

Current object types not supported (as of 1.0.0)
-----------------------------------------------------------

* Notifications
* Workflows
* Anything related to Mobile (including mobile menus)
* Anything related to Service Portal
* Anything related to Workspaces.
</description>
<mobile_callable>false</mobile_callable>
<name>xUpdateSetBuilder</name>
<sandbox_callable>false</sandbox_callable>
<script><![CDATA[var xUpdateSetBuilder = Class.create();
xUpdateSetBuilder.prototype = {
	
	_um: null,  //GlideUpdateManager2 used for capturing objects.
	_verbose: false,  //flag on whether to output verbose logging during operations.
	_capturedObjectMap: null,  //map of all captured objects to be added to update set.
	_capturedObjectCount: null,  //count of captured objects
    
	/**
	* @param isVerbose (boolean) - if true, certain operations will generate additional logging; nil otherwise. 
	*/
	initialize: function(isVerbose) {
		this._verbose = (true === isVerbose);
		this._capturedObjectMap = {};
		this._capturedObjectCount = 0;
		this._um = new GlideUpdateManager2();
    },
	
	///////////////////////////////////////////////// PUBLIC API /////////////////////////////////////////////////
	
	
	/**
	* This function will write any previously captured objects to the specified update set.  If the named update
	* set already exists in the current scope, it will re-use it; otherwise, it will create a new one with that name.
	* NOTE:  This function call must move the currently logged in user to the specified update set for the captured 
	* objects to be written to it; it will ALWAYS move the current user back to their originally selected update set
	* once completed, so the user should see no ill-effects.
	*
	* @param updateSetName (string) name of Update Set (in the current scope) to write captured updates to.
	*/
	writeUpdateSet: function(updateSetName) {
		if (JSUtil.nil(updateSetName))
			throw "xUpdateSetBuilder.writeUpdateSet: parameter 'updateSetName' is nil!";
		
		//Ensure current scope is accessible.
		var currentScopepGR = this._getCurrentScopeGR();
		var currentScopeSysId = "" + currentScopepGR.sys_id;
		gs.log("writeUpdateSet: Called to write captured objects to [UPDATE SET: '" + updateSetName 
			+ "', SCOPE: '" + currentScopepGR.name + "']");
		
		//Capture current user's selected update set to revert to at the end.
		var gus = new GlideUpdateSet();
		var currUpdateSetSysId = gus.get();
		var currUpdateSetGR = new GlideRecord(xUpdateSetBuilder._TABLES.UPDATE_SET);
		if (!currUpdateSetGR.get(currUpdateSetSysId))
			throw "xUpdateSetBuilder.writeUpdateSet: Unable to retrieve GR for current update set!";
		gs.log("writeUpdateSet: User's current update set is '" + currUpdateSetGR.name + "'");
		
		//Find update set; create if it doesn't exist.
		var usGR = new GlideRecord(xUpdateSetBuilder._TABLES.UPDATE_SET);
		usGR.addQuery("application", currentScopeSysId);
		usGR.addQuery("name", updateSetName);
		usGR.query();
		if (!usGR.next()) {
			usGR = new GlideRecord(xUpdateSetBuilder._TABLES.UPDATE_SET);
			usGR.initialize();
			usGR.application = currentScopeSysId;
			usGR.name = updateSetName;
			usGR.insert();
			gs.log("writeUpdateSet: CREATED new update set named '" + usGR.name + "'");
		} else {
			gs.log("writeUpdateSet: EXISTING update set named '" + usGR.name + "' found.");
		}
		
		//Change to the specified update set, capture all the objects in it, and then
		//return the current user back to their originally selected update set.
		try {
			//Set current update set to indicated update set for write.
			var writeUpdateSet = "" + usGR.sys_id;
			gs.log("writeUpdateSet: Moving to Update Set '" + usGR.name + "'");
			gus.set(writeUpdateSet);
		
			//Write all captured objects to Update Set
			gs.log("writeUpdateSet: Writing captured objects to update set\n");
			for (var sys_id in this._capturedObjectMap) {
				var tblName = this._capturedObjectMap[sys_id];
				var gr = new GlideRecord(tblName);
				if (gr.get("" + sys_id))
					this._um.saveRecord(gr);
			}
			gs.log("writeUpdateSet: Finished writing captured objects to update set");
			
		} catch (ex) {
			gs.log("writeUpdateSet: ERROR while writing update set!: " + ex);
		} finally {
			
			//Always flush the cache
			this._flushObjectCache();
			
			//Always switch back to originally selected Update Set, if applicable.
			gus.set(currUpdateSetSysId);
			if (gus.get() != currUpdateSetSysId)
				gs.log("writeUpdateSet: WARNING: Failed to move back to originally selected update set.  MAKE SURE TO DO SO MANUALLY");
			else
				gs.log("writeUpdateSet: Moved back to original update set '" + currUpdateSetGR.name + "' successfully");
		}
	},
	
	/**
	* Manually capturing a Table to an update set is notoriously difficult, as there are numerous secondary tables with artifacts 
	* related to that table and capturing just the table in an update set does NOT automatically trigger capture of those as xUpdateSetBuilder. 
	* This function provides that functionality so the entirety of a ServiceNow table/form can be captured atomically.  It captures 
	* the following related records for the specified table:
	*
	* 1.  Table Record (sys_db_object)
	* 2.  Table auto number, if applicable [Number Maintenance] (sys_number)
	* 3.  Table Dictionary Record ("collection" record in sys_dictionary)
	* 4.  Table fields (sys_dictionary) and their associated artifacts:
	*     a. Labels (sys_documentation)
	*     b. Choice Lists (sys_choice)
	*     c. Dictionary Overrides (sys_dictionary_override)
	*     d. Field-level ACL's (sys_security_acl, sys_security_acl_role)
	* 5.  Table-level ACL's (sys_security_acl, sys_security_acl_role)
	* 6.  Client Scripts (sys_script_client)
	* 7.  Business Rules (sys_script)
	* 8.  UI Actions (sys_ui_action)
	* 9.  UI Policies (sys_ui_policy, sys_ui_policy_action)
	* 10. Data Policies (sys_data_policy2, sys_data_policy_rule)
	* 11. Table Styles (sys_ui_style)
	* 12. View Rules (sysrule_view)
	* 
	* @param tblName (string) name of the table to capture to the update set.
	*/
	captureTableWithRelatedObjects: function(tblName) {
		if (JSUtil.nil(tblName))
			throw "xUpdateSetBuilder.captureTableWithRelatedObjects: parameter 'tblName' is nil!";
		tblName = "" + tblName;  //ensure string
		
		//Ensure table exists
		var tblGR = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_DB_OBJECT);
		if (!tblGR.get("name", tblName))
			throw "xUpdateSetBuilder.captureTableWithRelatedObjects: no table named '" 
				+ tblName + "' found!";
		
		//Save table record;
		this._recordObject(tblGR);
		
		//Save the "Collection" dictionary record for this table.
		var colDict = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_DICTIONARY);
		colDict.addQuery("name", tblName);
		colDict.addNullQuery("element");
		this._captureObjectsFromGRQuery(colDict);
		
		//Capture Number fields (Number Maintenance) if applicable
		this.captureTableNumber(tblName);
		
		//Capture table level ACL's for this table
		this.captureACLsForTable(tblName);
		
		//Capture Client scripts
		var clScript = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_SCRIPT_CLIENT);
		clScript.addQuery("table", tblName);
		this._captureObjectsFromGRQuery(clScript);
		
		//Capture all business rules on the table
		var br = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_SCRIPT);
		br.addQuery("collection", tblName);
		this._captureObjectsFromGRQuery(br);
		
		//Capture UI Actions
		var ua = new GlideRecord(xUpdateSetBuilder._TABLES.UI_ACTION);
		ua.addQuery("table", tblName);
		this._captureObjectsFromGRQuery(ua);
		
		//Capture UI Polices
		this.captureUIPolicesForTable(tblName);
		
		//Capture Data Polices
		this.captureDataPolicesForTable(tblName);
		
		//Capture table styles
		var uis = new GlideRecord(xUpdateSetBuilder._TABLES.UI_STYLE);
		uis.addQuery("name", tblName);
		this._captureObjectsFromGRQuery(uis);
		
		//Capture View Rules
		var vr = new GlideRecord(xUpdateSetBuilder._TABLES.TABLE_VIEW_RULE);
		vr.addQuery("table", tblName);
		this._captureObjectsFromGRQuery(vr);
		
		//Capture all Dictionary records and related objects.
		var dict = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_DICTIONARY);
		dict.addNotNullQuery("element");
		dict.addQuery("name", tblName);
		dict.query();
		while (dict.next()) {
			this.captureTableFieldAndAssociatedObjects(tblName, "" + dict.element);
		}
		
		//Capture Form Layouts, Related Lists, and Lists
		this.captureFormLayoutsForTable(tblName);
		this.captureListLayoutsForTable(tblName);
	},
	
	/**
	* This function captures the specified Database View (sys_db_view), its joined tables (sys_db_view_table), 
	* and the specified fields (sys_db_view_table_field) if applicable.  TODO It will also capture the associated 
	* List and Form Layouts for the Database View, if defined.
	*
	* @param vName (string) name of the Database View to capture.
	*/
	captureDatabaseView: function(vName) {
		if (JSUtil.nil(vName))
			throw "xUpdateSetBuilder.captureDatabaseView: parameter 'vName' is nil!";
		vName = "" + vName;  //ensure string
		
		//Capture Database View
		var vw = new GlideRecord(xUpdateSetBuilder._TABLES.DATABASE_VIEW);
		vw.addQuery("name", vName);
		vw.query();
		if (!vw.next())
			throw "xUpdateSetBuilder.captureDatabaseView: no DB view named '" + vName + "' found!'";
		this._recordObject(vw);
		
		//Capture Form and List Layouts
		//Capture Form Layouts, Related Lists, and Lists
		this.captureFormLayoutsForTable(vName);
		this.captureListLayoutsForTable(vName);
		
		//Capture View Tables
		var tbl = new GlideRecord(xUpdateSetBuilder._TABLES.DATABASE_VIEW_TABLE);
		tbl.addQuery("view", "" + vw.sys_id);
		tbl.query();
		while (tbl.next()) {
			this._recordObject(tbl);
			
			//Capture View Table's View Fields if applicable.
			var fld = new GlideRecord(xUpdateSetBuilder._TABLES.DATABASE_VIEW_TABLE_FIELD);
			fld.addQuery("view_table", "" + tbl.sys_id);
			fld.query();
			while (fld.next()) {
				this._recordObject(fld);
			}
		}
	},
	
	/**
	* This function allows for capturing an Application Menu (and its related modules) to an update set.  
	* Since Application Menus can, in theory, have multiple with the same name, this function requires 
	* specifying the sys_id of the intended menu for safety.
	*
	* @param menuSysId (string) sys_id of the Application Menu to capture.
	*/
	captureApplicationMenuAndModules: function(menuSysId) {
		if (JSUtil.nil(menuSysId))
			throw "xUpdateSetBuilder.captureApplicationMenuAndModules: parameter 'menuSysId' is nil!";
		menuSysId = "" + menuSysId;  //ensure string
		
		//Capture app menu.
		var appMenu = new GlideRecord(xUpdateSetBuilder._TABLES.APPLICATION_MENU);
		if (!appMenu.get(menuSysId))
			throw "xUpdateSetBuilder.captureApplicationMenuAndModules: no App menu found for sys_id '" 
				+ menuSysId + "'";
		this._recordObject(appMenu);
		
		//Capture related modules.
		var mod = new GlideRecord(xUpdateSetBuilder._TABLES.APPLICATION_MENU_MODULE);
		mod.addQuery("application", "" + appMenu.sys_id);
		this._captureObjectsFromGRQuery(mod);
		
		//TODO Capture mobile modules
	},
	
	/**
	* This function allows for capturing a Script Include to an update set; in order to avoid any confusion,
	* the parameter to specify is the API Name (as shown on the Script Include form), not the main Name field
	*
	* @param scrName (string) The API Name of the script include to capture.
	*/
	captureScriptIncludeByName: function(scrName) {
		if (JSUtil.nil(scrName))
			throw "xUpdateSetBuilder.captureScriptIncludeByName: parameter 'scrName' is nil!";
		var apiName = this._getCurrentScopeName() + "." + scrName;  //Get unique scoped API name
		
		var scr = new GlideRecord(xUpdateSetBuilder._TABLES.SCRIPT_INCLUDE);
		scr.addQuery("api_name", apiName);
		this._captureUniqueGRObject(scr, "xUpdateSetBuilder.captureScriptIncludeByName");
	},
	
	/**
	* This function captures the specified role (from the current scope) into the update set.
	*
	* @param roleName (string) The name of the role to capture.
	*/
	captureUserRole: function(roleName) {
		if (JSUtil.nil(roleName))
			throw "xUpdateSetBuilder.captureUserRole: parameter 'roleName' is nil!";
		roleName = "" + roleName;  //ensure string
		
		var rol = new GlideRecord(xUpdateSetBuilder._TABLES.ROLE);
		rol.addQuery("sys_scope", this._getCurrentScopeName());
		rol.addQuery("name", roleName);
		this._captureUniqueGRObject(rol, "xUpdateSetBuilder.captureUserRole");		
	},
	
	/**
	* This function captures the Application record (sys_app) specified.  While these are typically created when 
	* building scoped apps, and so almost never need to be manually captured, the Application table pre-dates the 
	* Scoped Application functionality and so there will occasionally be Application records tied to global scope 
	* that may need to be captured into an update set for transport.
	*
	* @param appName (string) The name of the Application (Name field) to capture (from the current scope).
	*/
	captureApplicationRecord: function(appName) {
		if (JSUtil.nil(appName))
			throw "xUpdateSetBuilder.captureTableNumber: parameter 'appName' is nil!";
		appName = "" + appName;  //ensure string
		
		var app = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_APPLICATION);
		app.addQuery("name", appName);
		this._captureUniqueGRObject(app, "xUpdateSetBuilder.captureApplicationRecord");
	},
	
	/**
	* This function allows for capturing a specified System Property Category (sys_properties_category) and its
	* associated System Properties (sys_properties and the sys_properties_category_m2m association records).  
	* It allows for capturing an entire cateogory of System Properties as an atomic unit.
	*
	* @param catName (string) The name of the Property Category
	*/
	captureSystemPropertyCategoryWithAssociations: function(catName) {
		if (JSUtil.nil(catName))
			throw "captureSystemPropertyCategory: parameter 'catName' is nil!";
		
		//Capture the specified Category
		var cat = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_PROPERTIES_CATEGORY);
		cat.addQuery("name", catName);
		this._captureUniqueGRObject(cat, "xUpdateSetBuilder.captureSystemPropertyCategoryWithAssociations");
		
		//Capture all related properties.
		var assoc = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_PROPERTIES_CATEGORY_ASSOC);
		assoc.addQuery("category", "" + cat.sys_id);
		assoc.addNotNullQuery("property");  //should never happen
		assoc.query();
		while (assoc.next()) {
			var prop = assoc.property.getRefRecord();
			
			//Capture the system property itself
			this.captureSystemProperty("" + prop.name);
			
			//Capture Association to Category record.
			this._recordObject(assoc);
		}
	},
	
	/**
	* Captures the specified System Property (as specified in the Name field, NOT just the Suffix field).
	*
	* @param propName (string) The name of the System Property to capture.
	*/
	captureSystemProperty: function(propName) {
		if (JSUtil.nil(propName))
			throw "xUpdateSetBuilder.captureSystemProperty: parameter 'propName' is nil!";
		
		//Capture specified system property (should only ever be one).
		var prop = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_PROPERTIES);
		prop.addQuery("name", propName);
		this._captureUniqueGRObject(prop, "xUpdateSetBuilder.captureSystemProperty");
	},
	
	/**
	* Captures the specified System Event (as specified in the Name field, NOT just the Suffix field).
	*
	* @param evtName (string) The name of the System Eventy to capture.
	*/
	captureEventRegistration: function(evtName) {
		if (JSUtil.nil(evtName))
			throw "xUpdateSetBuilder.captureEventRegistration: parameter 'evtName' is nil!";
		
		var evt = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_EVENT);
		evt.addQuery("event_name", evtName);
		this._captureUniqueGRObject(evt, "xUpdateSetBuilder.captureEventRegistration");
	},
	
	/**
	* This function allows for capturing data records from a table that is not normally captured by Update Sets (i.e. a table that does 
	* not extend Application File).  It is useful for situations where an update set creates tables that need some baseline level of data
	* in them before use (ex. Tables that contain configuration records).
	*
	* @param tblName (string) name of the table with records to be captured
	* @param queryCondition (string) [optional] if specified, encoded query to filter results of records to be captured from table.
	*/
	captureDataRecordsFromTable: function(tblName, queryCondition) {
		if (JSUtil.nil(tblName))
			throw "xUpdateSetBuilder.captureDataRecordsFromTable: parameter 'tblName' is nil!";
		tblName = "" + tblName;  //ensure string
		
		//Capture rows in specified table
		var gr = new GlideRecord(tblName);
		if (JSUtil.notNil(queryCondition))
			gr.addEncodedQuery("" + queryCondition);  //ensure string
		gr.query();
		this._captureObjectsFromGRQuery(gr);
		gs.log("xUpdateSetBuilder.captureDataRecordsFromTable: captured " + gr.getRowCount() + " records");
	},
	
	/**
	* Whereas the captureDataRecordsFromTable() function is used to specify a table and an (optional) condition for a set of records to 
	* query and capture, this function allows for capturing a specific data record not normally captured by Update Sets (i.e. a table that
	* does not extend Application File) that has already been queried.  It is useful for situations where an update set creates tables that
	* need some baseline level of data in them before use (ex. Tables that contain configuration records).
	*
	* @param gr (GlideRecord) GlideRecord of object to capture.
	*/
	captureDataRecord: function(gr) {
		if (gr === null)
			throw "xUpdateSetBuilder.captureDataRecord: parameter 'gr' is null!";
		if (gr === undefined)
			throw "xUpdateSetBuilder.captureDataRecord: parameter 'gr' is undefined!";
		if (!(gr instanceof GlideRecord))
			throw "xUpdateSetBuilder.captureDataRecord: parameter 'gr' must be a GlideRecord!";
		var tblName = gr.getTableName();
		if (JSUtil.nil(tblName))
			throw "xUpdateSetBuilder.captureDataRecord: parameter 'gr' must be initialied to a table!";
		
		//Capture record
		this._recordObject(gr);
	},
	
	/**
	* This function captures TABLE-level ACL's (and role-dependencies) for the specified table.  While its typical use is by the 
	* captureTableWithRelatedObjects() function in capturing the entirety of a table, it is nevertheless available for use directly
	* in cases where only capturing the ACL's for a table to an update set is needed.
	*
	* @param tblName (string) name of the table to capture table-level ACL's for.
	*/
	captureACLsForTable: function(tblName) {
		if (JSUtil.nil(tblName))
			throw "xUpdateSetBuilder.captureACLsForTable: parameter 'tblName' is nil!";
		tblName = "" + tblName;  //ensure string
		
		//Ensure table exists
		var tblGRCount = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_DB_OBJECT);
		tblGRCount.addQuery("name", tblName);
		tblGRCount.query();
		if (!tblGRCount.hasNext())
			throw "xUpdateSetBuilder.captureACLsForTable: no table named '" 
				+ tblName + "' found!";
		
		//Capture all TABLE level ACL's for the specified table (exclude FIELD level ACL's)
		var acl = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_SECURITY_ACL);
		acl.addQuery("name", tblName);
		acl.query();
		while (acl.next()) {
			this._recordObject(acl);
			
			//Capture any ACL required roles
			var aclRole = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_SECURITY_ACL_ROLE);
			aclRole.addQuery("sys_security_acl", "" + acl.sys_id);
			aclRole.query();
			this._captureObjectsFromGRQuery(aclRole);
		}
	},
	
	/**
	* This function captures FIELD-level ACL's (and role-dependencies) for the specified table and field.  While its typical use is by
	* the captureTableWithRelatedObjects() function in capturing the entirety of a table, it is nevertheless available for use directly 
	* in cases where only capturing the ACL's for a table field to an update set is needed.
	*
	* @param tblName (string) name of the table containing the field to capture field-level ACL's for.
	* @param fieldName (string) name of the field to capture field-level ACL's for.
	*/
	captureACLsForTableAndField: function(tblName, fieldName) {
		if (JSUtil.nil(tblName))
			throw "xUpdateSetBuilder.captureACLsForTableAndField: parameter 'tblName' is nil!";
		if (JSUtil.nil(fieldName))
			throw "xUpdateSetBuilder.captureACLsForTableAndField: parameter 'fieldName' is nil!";
		tblName = "" + tblName;  //ensure string
		fieldName = "" + fieldName;  //ensure string.
		
		//Ensure table exists
		var tblGRCount = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_DB_OBJECT);
		tblGRCount.addQuery("name", tblName);
		tblGRCount.query();
		if (!tblGRCount.hasNext())
			throw "xUpdateSetBuilder.captureACLsForTableAndField: no table named '" 
				+ tblName + "' found!";
		
		//Ensure field exists
		var fieldGRCount = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_DICTIONARY);
		fieldGRCount.addQuery("name", tblName);
		fieldGRCount.addQuery("element", fieldName);
		fieldGRCount.query();
		if (!fieldGRCount.hasNext())
			throw "xUpdateSetBuilder.captureACLsForTableAndField: no field named '" 
				+ fieldName + "' found on table '" + tblName + "' found!";
		
		//Capture all FIELD level ACL's for the specified table and field
		var acl = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_SECURITY_ACL);
		acl.addQuery("name", tblName + "." + fieldName);
		acl.query();
		while (acl.next()) {
			this._recordObject(acl);
			
			//Capture any ACL required roles
			var aclRole = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_SECURITY_ACL_ROLE);
			aclRole.addQuery("sys_security_acl", "" + acl.sys_id);
			this._captureObjectsFromGRQuery(aclRole);
		}
	},
	
	/**
	* This function captures UI Policies (and child UI Policy Actions) for the specified table.  While its typical use is by
	* the captureTableWithRelatedObjects() function in capturing the entirety of a table, it is nevertheless available for use
	* directly in cases where only capturing the UI Policies for a table to an update set is needed.
	*
	* @param tblName (string) name of the table for the UI Polices to capture.
	*/
	captureUIPolicesForTable: function(tblName) {
		if (JSUtil.nil(tblName))
			throw "xUpdateSetBuilder.captureUIPolicesForTable: parameter 'tblName' is nil!";
		tblName = "" + tblName;  //ensure string
		
		//Ensure table exists
		var tblGRCount = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_DB_OBJECT);
		tblGRCount.addQuery("name", tblName);
		tblGRCount.query();
		if (!tblGRCount.hasNext())
			throw "xUpdateSetBuilder.captureUIPolicesForTable: no table named '" 
				+ tblName + "' found!";
		
		//Capture all UI Polices for this table
		var ui = new GlideRecord(xUpdateSetBuilder._TABLES.UI_POLICY);
		ui.addQuery("table", tblName);
		ui.query();
		while (ui.next()) {
			this._recordObject(ui);
			
			//Capture UI Policy Actions
			var uia = new GlideRecord(xUpdateSetBuilder._TABLES.UI_POLICY_ACTION);
			uia.addQuery("ui_policy", "" + ui.sys_id);
			uia.query();
			this._captureObjectsFromGRQuery(uia);
		}
	},
	
	/**
	* This function captures Data Policies (and child Data Policy Rules) for the specified table.  While its typical use is by 
	* the captureTableWithRelatedObjects() function in capturing the entirety of a table, it is nevertheless available for use
	* directly in cases where only capturing the Data Policies for a table to an update set is needed.
	*
	* @param tblName (string) name of the table for the Data Polices to capture.
	*/
	captureDataPolicesForTable: function(tblName) {
		if (JSUtil.nil(tblName))
			throw "xUpdateSetBuilder.captureDataPolicesForTable: parameter 'tblName' is nil!";
		tblName = "" + tblName;  //ensure string
		
		//Ensure table exists
		var tblGRCount = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_DB_OBJECT);
		tblGRCount.addQuery("name", tblName);
		tblGRCount.query();
		if (!tblGRCount.hasNext())
			throw "xUpdateSetBuilder.captureDataPolicesForTable: no table named '" 
				+ tblName + "' found!";
		
		//Capture all Data Polices for this table
		var dp = new GlideRecord(xUpdateSetBuilder._TABLES.DATA_POLICY);
		dp.addQuery("model_table", tblName);
		dp.query();
		while (dp.next()) {
			this._recordObject(dp);
			
			//Capture Data Policy Rules
			var dpr = new GlideRecord(xUpdateSetBuilder._TABLES.DATA_POLICY_RULE);
			dpr.addQuery("sys_data_policy", "" + dp.sys_id);
			this._captureObjectsFromGRQuery(dpr);
		}
	},
	
	/**
	* This function allows for capturing a auto numbers (Number Maintenance) [sys_number] for the specified 
	* table; while there is usually only one auto number per table, this method will capture all of them if 
	* there are multiple for that table.
	*
	* @param tblName (string) name of the table to get auto numbers for.
	*/
	captureTableNumber: function(tblName) {
		if (JSUtil.nil(tblName))
			throw "xUpdateSetBuilder.captureTableNumber: parameter 'tblName' is nil!";
		tblName = "" + tblName;  //ensure string
		
		//Ensure table exists
		var tblGR = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_DB_OBJECT);
		if (!tblGR.get("name", tblName))
			throw "xUpdateSetBuilder.captureTableNumber: no table named '" 
				+ tblName + "' found!";
		
		var nm = new GlideRecord(xUpdateSetBuilder._TABLES.TABLE_NUMBER);
		nm.addQuery("category", tblName);
		this._captureObjectsFromGRQuery(nm);
	},
	
	/**
	* This function allows for capturing List Layouts [sys_ui_list] (and all associated artifacts), for all views on
	* the specified table; fortunately, the platform will capture the associated child UI elements anytime a List Layout
	* is captured, therefore, we don't have to explicitly do it here.  While the typical use of this function is by the 
	* captureTableWithRelatedObjects() function in capturing the entirety of a table, it is nevertheless available for use
	* directly in cases where only capturing the List Layouts for a table to an update set is needed.
	*
	* @param tblName (string) name of the table to capture all List Layouts for.
	*/
	captureListLayoutsForTable: function(tblName) {
		if (JSUtil.nil(tblName))
			throw "xUpdateSetBuilder.captureListLayoutsForTable: parameter 'tblName' is nil!";
		tblName = "" + tblName;  //ensure string
		
		//1. Capture List Layouts
		var lst = new GlideRecord(xUpdateSetBuilder._TABLES.LIST_LAYOUT);
		lst.addQuery("name", tblName);
		lst.addNotNullQuery("view");  //Must be tied to a view
		lst.addNullQuery("sys_user");  //We don't want user personalized list layouts.
		lst.addNullQuery("relationship");  //We don't want list layouts for Relationship records.
		lst.query();
		while (lst.next()) {
			
			//If View Name starts with RPT then it's for a list view report and we don't want it.
			var vw = lst.view.getRefRecord();
			var vwNameUpper = ("" + vw.name).toUpperCase();
			if (vwNameUpper.startsWith("RPT"))
				continue;			
			
			//Ensure dependent View for this Form Layout already captured.
			this._captureUIView("" + vw.sys_id);
			
			//Capture the List Layout
			//NOTE: When capturing a List Layout record, the GlideUpdateManager class will
			//automatically record the child UI Element records as xUpdateSetBuilder, so we don't need to do
			//it here explicitly.
			this._recordObject(lst);
		}
		
		//2. Capture List Control
		var lc = new GlideRecord(xUpdateSetBuilder._TABLES.LIST_CONTROL);
		lc.addQuery("name", tblName);
		lc.query();
		while (lc.next())
			this._recordObject(lc);
	},
	
	/**
	* This function allows for capturing Form Layouts [sys_ui_section] (and all associated artifacts), for all views on the 
	* specified table; fortunately, the platform will capture the associated child UI elements anytime a Form Layout is captured,
	* therefore, we don't have to explicitly do it here.  While the typical use of this function is by the 
	* captureTableWithRelatedObjects() function in capturing the entirety of a table, it is nevertheless available for use directly
	* in cases where only capturing the Form Layouts for a table to an update set is needed.
	*
	* NOTE: This method also captures all Related Lists (sys_ui_related_list) for each Form Layout, since they are part of the designed
	* Form Layout; as with Form and List Layouts, the child elements of a Related List record are automatically captured by the platform
	* when a Related List is captured, therefore we don't explicitly have to capture them here.
	*
	* @param tblName (string) name of the table to capture all Form Layouts and associated Related Lists for.
	*/
	captureFormLayoutsForTable: function(tblName) {
		if (JSUtil.nil(tblName))
			throw "xUpdateSetBuilder.captureFormLayoutsForTable: parameter 'tblName' is nil!";
		tblName = "" + tblName;  //ensure string
		
		//Capture all Form records (one per view) and associated Form Sections (tabs, elements)
		var frm = new GlideRecord(xUpdateSetBuilder._TABLES.FORM);
		frm.addQuery("name", tblName);
		frm.addNotNullQuery("view");  //eliminate any bad data.
		frm.query();
		while (frm.next()) {
			
			//If View Name starts with RPT then it's for a form view on a report and we don't want it.
			var vw = frm.view.getRefRecord();
			var vwSysId = "" + vw.sys_id;
			var vwNameUpper = ("" + vw.name).toUpperCase();
			if (vwNameUpper.startsWith("RPT"))
				continue;
			
			//1. Capture the Form record
			this._recordObject(frm);
			
			//2. Iterate through the Form Section records (sys_ui_form_section)[These are the individual tabs on the form.]
			//to capture the individual Form Section records (sys_ui_section)[These define the layout on each tab and form].
			//NOTE: We don't have to capture the top level Form Section (sys_ui_form_section) records cause the Update Set
			//API automatically does that when capturing the Form record.
			var frs1 = new GlideRecord(xUpdateSetBuilder._TABLES.FORM_SECTION);
			frs1.addQuery("sys_ui_form", "" + frm.sys_id);
			frs1.addNotNullQuery("sys_ui_section");  //eliminate any bad data.
			frs1.query();
			while (frs1.next()) {
				
				//Capture the each child Form Section (sys_ui_section) record.
				//NOTE: We don't have to capture the child Section Element (sys_ui_element) records cause the Update Set
				//API automatically does that when capturing their parent Form Section (sys_ui_section) record.
				var frs2 = frs1.sys_ui_section.getRefRecord();
				this._recordObject(frs2);
			}
		
			//3. Grab Related Lists for this Form and View combo
			//Capture Releated Lists.  
			//NOTE: When capturing a Related List record, the GlideUpdateManager class will
			//automatically record the child UI Element records as xUpdateSetBuilder, so we don't need to do
			//it here explicitly.
			var rel = new GlideRecord(xUpdateSetBuilder._TABLES.FORM_RELATED_LIST);
			rel.addQuery("name", tblName);
			rel.addQuery("view", vwSysId);
			rel.query();
			if (rel.next()) {  //should only ever be one.
				
				//Capture the Related List record.
				//NOTE: We don't have to capture the child RElated List Entries (sys_ui_related_list_entry) records cause
				//the Update Set API automatically does that when capturing their parent Related List record.
				this._recordObject(rel);
				
			} else
				gs.log("WARNING: No Related List found for Table '" + tblName + "' for View '" + vw.name + "'");
		}
	},
	
	/**
	* This function captures a specified Field for the specified table (and related objects).  While its typical use is by 
	* the captureTableWithRelatedObjects() function in capturing the entirety of a table field, it is nevertheless available for use
	* directly in cases where only capturing an individual field to an update set is needed.
	*
	* @param tblName (string) name of the table for the Data Polices to capture.
	*/
	captureTableFieldAndAssociatedObjects: function(tblName, fldName) {
		if (JSUtil.nil(tblName))
			throw "xUpdateSetBuilder.captureTableFieldAndAssociatedObjects: parameter 'tblName' is nil!";
		tblName = "" + tblName;  //ensure string
		if (JSUtil.nil(fldName))
			throw "xUpdateSetBuilder.captureTableFieldAndAssociatedObjects: parameter 'fldName' is nil!";
		fldName = "" + fldName;  //ensure string
		
		//Ensure field exists on table.
		var dict = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_DICTIONARY);
		dict.addQuery("name", tblName);
		dict.addQuery("element", fldName);
		dict.query();
		if (!dict.next())
			throw "xUpdateSetBuilder.captureTableFieldAndAssociatedObjects: No field named '" + fldName 
				+ "' on table '" + tblName + "' found!";
		
		//save the Dictionary record for field.
		this._recordObject(dict);
		
		//Get Label records for this field.
		var lbl = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_DOCUMENTATION);
		lbl.addQuery("name", tblName);
		lbl.addQuery("element", fldName);
		this._captureObjectsFromGRQuery(lbl);

		//Get any choice lists
		var cho = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_CHOICE);
		cho.addQuery("name", tblName);
		cho.addQuery("element", fldName);
		this._captureObjectsFromGRQuery(cho);

		//Capture FIELD level ACL's for this table and field.
		this.captureACLsForTableAndField(tblName, fldName);

		//Capture dictionary overrides
		var over = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_DICTIONARY_OVERRIDE);
		over.addQuery("name", tblName);
		over.addQuery("element", fldName);
		this._captureObjectsFromGRQuery(over);
	},
	
	/**
	* This function captures a specified Archive Rule (and related objects).
	*
	* @param ruleSysId (string) sys_id of the System Archive rule to capture.
	*/
	captureArchivalRule: function(ruleSysId) {
		if (JSUtil.nil(ruleSysId))
			throw "captureArchivalRule: parameter 'ruleSysId' is nil!";
		ruleSysId = "" + ruleSysId;  //ensure string
		
		//Ensure exists
		var rul = new GlideRecord(xUpdateSetBuilder._TABLES.ARCHIVE_RULE);
		if (!rul.get(ruleSysId))
			throw "xUpdateSetBuilder.captureArchivalRule: No archive rule found for sys_id " + ruleSysId;
		this._recordObject(rul);
		
		//Capture any "Archive Related Records" child records.
		var rel = new GlideRecord(xUpdateSetBuilder._TABLES.ARCHIVE_RULE_RELATED);
		rel.addQuery("archive_map", ruleSysId);
		rel.query();
		while (rel.next()) {
			
			//Capture Rel Record.
			this._recordObject(rel);
			
			//If this record references another Table Rule, then that must also be captured.
			if (!rel.table_archive_rule.nil()) {
				
				//Ensure no circular references
				var chld = "" + rel.table_archive_rule;
				if (chld != ruleSysId)
					this.captureArchivalRule(chld);
			}
		}
	},
	
	isVerbose: function() {
		return (this._verbose === true);
	},
	
	getObjectCount: function() {
		return this._capturedObjectCount;
	},
	
	
	///////////////////////////////////////////// INTERNAL FUNCTIONS /////////////////////////////////////////////
	
	/**
	* Several supported objects for capture (List Layouts, Form Layouts, Related Lists) are necessarily linked to
	* a UI View for the specific view of the Table/Form they are for; therefore, these functions will end up making
	* many calls to ensure the dependent views have been captured, and if not, automatically capture them even if
	* the caller didn't specify to capture them.  In order to avoid repeated that logic, this function is called
	* by those respective functions to perform this check and capture the View record if necessary.
	*
	* @param sys_id (string) sys_id of the sys_ui_view record to capture.
	*/
	_captureUIView: function(sys_id) {
		if (JSUtil.nil(sys_id))
			throw "xUpdateSetBuilder.captureUIViewsForTable: parameter 'sys_id' is nil!";
		sys_id = "" + sys_id;  //ensure string
		
		//Only capture if not already
		if (!this._capturedObjectMap[sys_id]) {
			var uiv = new GlideRecord(xUpdateSetBuilder._TABLES.UI_VIEW);
			if (!uiv.get(sys_id))
				throw "xUpdateSetBuilder.captureUIViewsForTable: No UI View found for sys_id '" 
					+ sys_id + "'";
			
			//Record UI View since not already in cache.
			gs.log("Capturing UI View '" + uiv.title + "'");
			this._recordObject(uiv);
		}
	},
	
	/**
	* Several of the public API functions capture objects, for which there should only ever be ONE record
	* for the given conditions. As a result, those functions need to perform error checking to ensure the
	* query they've built to retrieve it only returns exactly one record and errors out otherwise. This
	* internal function performs that check and records the object only if exactly one is returned.
	*
	* @param gr (GlideRecord) A GlideRecord object with query conditions pre-loaded.
	* @param callingMethod (string) name of the function calling this function, to be included in the error
	*                               that is thrown if there is an issue.
	*/
	_captureUniqueGRObject: function(gr, callingMethod) {
		if (!gr)
			throw "xUpdateSetBuilder._captureUniqueGRObject: parameter 'gr' is nil!";
		gr.query();
		
		//Only record the object if there is exactly one, as expected.
		if (gr.getRowCount() == 1 && gr.next())
			this._recordObject(gr);
		
		//Otherwise throw the appropriate error for the actual result found.
		else if (gr.getRowCount() < 1) {
			throw callingMethod + ": No " + gr.getTableName() + " found for query '" 
				+ gr.getEncodedQuery() + "'";
		} else
			throw callingMethod + ": found multiple (" + gr.getRowCount() + ") " + gr.getTableName() + " for provided query!";
	},
	
	/**
	* Many of the public API functions capture a series of objects based on some query criteria, and then 
	* iterate through the results capturing each object. This internal function is used to delegate that 
	* boiler-plate logic.  It wil call the query() method on the GlideRecord and then capture every
	* object in the result set.
	*
	* @param gr (GlideRecord) A GlideRecord object with query conditions pre-loaded.
	*/
	_captureObjectsFromGRQuery: function(gr) {
		if (!gr)
			throw "xUpdateSetBuilder._captureObjectsFromGRQuery: parameter 'gr' is nil!";
		//TODO additional validations
		
		//Run provided query and capture all records from it.
		gr.query();
		while (gr.next())
			this._recordObject(gr);
	},
	
	/**
	* This core function is used by all the public API functions to perform the task of capturing a 
	* specified  GlideRecord object for capture in an update set.
	*
	* @param gr (GlideRecord) object to capture for recording to an update set.
	*/
	_recordObject: function(gr) {
		if (!gr)
			return;
		
		//Mapping: sys_id -> table of object. (only parameters needed to capture object in Update Set).
		var sys_id = "" + gr.sys_id;
		var capturedObject = this._capturedObjectMap[sys_id];
		if (!capturedObject) {
			capturedObject = this._capturedObjectMap[sys_id] = gr.getTableName();
			
			//Increment counter and output logs if applicable.
			this._capturedObjectCount++;
			if (this.isVerbose())
				gs.log("Captured '" + gr.getTableName() + " object with sys_id '" + sys_id + "'");
		}
	},
	
	/**
	* WORKAROUND FUNCTION: There are a few places where knowing the user's current selected scope is required; 
	* ServiceNow provides a GlideSystem function for this purpose (getCurrentScopeName), however when in the Global 
	* scope, it returns "rhino.global" instead of just "global" as expected.  This function simply calls getCurrentScope
	* and returns "global" in the case the user is in Global scope, or the true value otherwise..
	*/
	_getCurrentScopeName: function() {
		var scp = gs.getCurrentScopeName();
		return (scp == "rhino.global") ? "global" : scp;
	},
	
	/**
	* Returns the GlideRecord (sys_scope) for the user's current scope.
	*/
	_getCurrentScopeGR: function() {
		var sn = this._getCurrentScopeName();
		if (JSUtil.nil(sn))
			throw "xUpdateSetBuilder._getCurrentScopeGR: No scope name found!";  //should never happen.
		
		//Return Scope GR
		var scp = new GlideRecord(xUpdateSetBuilder._TABLES.SYS_SCOPE);
		if (!scp.get("name", sn))
			throw "xUpdateSetBuilder._getCurrentScopeGR: No scope found with name '" + sn + "'";
		return scp;
	},
	
	_flushObjectCache: function() {
		this._capturedObjectMap = {};
		this._capturedObjectCount = 0;
	},

    type: 'xUpdateSetBuilder',
	version: '1.0.0'
};

//Enum of all tables supported by this utility.
xUpdateSetBuilder._TABLES = {};
xUpdateSetBuilder._TABLES.SYS_SCOPE = "sys_scope";
xUpdateSetBuilder._TABLES.UPDATE_SET = "sys_update_set";
xUpdateSetBuilder._TABLES.SYS_APPLICATION = "sys_app";
xUpdateSetBuilder._TABLES.SYS_PROPERTIES = "sys_properties";
xUpdateSetBuilder._TABLES.SYS_PROPERTIES_CATEGORY = "sys_properties_category";
xUpdateSetBuilder._TABLES.SYS_PROPERTIES_CATEGORY_ASSOC = "sys_properties_category_m2m";
xUpdateSetBuilder._TABLES.SYS_DB_OBJECT = "sys_db_object";
xUpdateSetBuilder._TABLES.SYS_DICTIONARY = "sys_dictionary";
xUpdateSetBuilder._TABLES.UI_VIEW = "sys_ui_view";
xUpdateSetBuilder._TABLES.SYS_EVENT = "sysevent_register";
xUpdateSetBuilder._TABLES.LIST_LAYOUT = "sys_ui_list";
xUpdateSetBuilder._TABLES.LIST_CONTROL = "sys_ui_list_control";
xUpdateSetBuilder._TABLES.FORM = "sys_ui_form";
xUpdateSetBuilder._TABLES.FORM_SECTION = "sys_ui_form_section";
xUpdateSetBuilder._TABLES.FORM_LAYOUT = "sys_ui_section";
xUpdateSetBuilder._TABLES.FORM_RELATED_LIST = "sys_ui_related_list";
xUpdateSetBuilder._TABLES.SYS_DOCUMENTATION = "sys_documentation";
xUpdateSetBuilder._TABLES.SYS_CHOICE = "sys_choice";
xUpdateSetBuilder._TABLES.SYS_SECURITY_ACL = "sys_security_acl";
xUpdateSetBuilder._TABLES.SYS_SECURITY_ACL_ROLE = "sys_security_acl_role";
xUpdateSetBuilder._TABLES.SYS_DICTIONARY_OVERRIDE = "sys_dictionary_override";
xUpdateSetBuilder._TABLES.SYS_SCRIPT = "sys_script";
xUpdateSetBuilder._TABLES.SYS_SCRIPT_CLIENT = "sys_script_client";
xUpdateSetBuilder._TABLES.SCRIPT_INCLUDE = "sys_script_include";
xUpdateSetBuilder._TABLES.UI_ACTION = "sys_ui_action";
xUpdateSetBuilder._TABLES.UI_POLICY = "sys_ui_policy";
xUpdateSetBuilder._TABLES.UI_POLICY_ACTION = "sys_ui_policy_action";
xUpdateSetBuilder._TABLES.DATA_POLICY = "sys_data_policy2";
xUpdateSetBuilder._TABLES.DATA_POLICY_RULE = "sys_data_policy_rule";
xUpdateSetBuilder._TABLES.UI_STYLE = "sys_ui_style";
xUpdateSetBuilder._TABLES.TABLE_VIEW_RULE = "sysrule_view";
xUpdateSetBuilder._TABLES.APPLICATION_MENU = "sys_app_application";
xUpdateSetBuilder._TABLES.APPLICATION_MENU_MODULE = "sys_app_module";
xUpdateSetBuilder._TABLES.DATABASE_VIEW = "sys_db_view";
xUpdateSetBuilder._TABLES.DATABASE_VIEW_TABLE = "sys_db_view_table";
xUpdateSetBuilder._TABLES.DATABASE_VIEW_TABLE_FIELD = "sys_db_view_table_field";
xUpdateSetBuilder._TABLES.ROLE = "sys_user_role";
xUpdateSetBuilder._TABLES.TABLE_NUMBER = "sys_number";
xUpdateSetBuilder._TABLES.ARCHIVE_RULE = "sys_archive";
xUpdateSetBuilder._TABLES.ARCHIVE_RULE_RELATED = "sys_archive_related";]]></script>
<sys_class_name>sys_script_include</sys_class_name>
<sys_created_by>github.com/derekpage3</sys_created_by>
<sys_created_on>2020-07-06 19:07:05</sys_created_on>
<sys_id>5c43669e2f711010ae1d808cf699b67b</sys_id>
<sys_mod_count>95</sys_mod_count>
<sys_name>xUpdateSetBuilder</sys_name>
<sys_package display_value="Global" source="global">global</sys_package>
<sys_policy/>
<sys_scope display_value="Global">global</sys_scope>
<sys_update_name>sys_script_include_5c43669e2f711010ae1d808cf699b67b</sys_update_name>
<sys_updated_by>github.com/derekpage3</sys_updated_by>
<sys_updated_on>2026-01-12 17:59:44</sys_updated_on>
</sys_script_include>
</unload>
